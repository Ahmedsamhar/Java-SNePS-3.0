package sneps.snepslog;

import java.io.*;
import java_cup.runtime.*;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Set;

import sneps.network.Node;
import sneps.network.PropositionNode;
import sneps.network.Network;
import sneps.network.paths.Path;
import sneps.network.paths.BangPath;
import sneps.network.paths.EmptyPath;
import sneps.network.paths.BUnitPath;
import sneps.network.paths.FUnitPath;
import sneps.network.paths.CFResBUnitPath;
import sneps.network.paths.CFResFUnitPath;
import sneps.network.paths.AndPath;
import sneps.network.paths.ComposePath;
import sneps.network.paths.ConversePath;
import sneps.network.paths.DomainRestrictPath;
import sneps.network.paths.IrreflexiveRestrictPath;
import sneps.network.paths.KPlusPath;
import sneps.network.paths.KStarPath;
import sneps.network.paths.OrPath;
import sneps.network.paths.RangeRestrictPath;
import sneps.snebr.Controller;
import sneps.exceptions.ContextNameDoesntExistException;


parser code {:
String command;
:};
	
/* Terminals (tokens returned by the scanner). */

terminal ACTIVATE,
         BANG,
         DOT,
         ADD_TO_CONTEXT,
         ASK,
         ASKIFNOT,
         ASKWH,
         ASKWHNOT,
         BELIEFS_ABOUT,
         BR_MODE,
         AUTO,
         MANUAL,
         CLEAR_INFER,
         CLEARKB,
         COPYRIGHT,
         DEFINE_FRAME,
         DEFINE_PATH,
         DEFINE_SEMANTIC,
         DEFINE_RELATION,
         QUESTION_MARK,
         DESCRIBE_CONTEXT,
         DESCRIBE_TERMS,
         EXPERT,
         LIST_ASSERTED_WFFS,
         LIST_CONTEXTS,
         LIST_TERMS,
         LOAD,
         NORMAL,
         PERFORM,
         REMOVE_FROM_CONTEXT,
         SET_CONTEXT,
         SET_DEFAULT_CONTEXT,
         SET_MODE_1,
         SET_MODE_2,
         SET_MODE_3,
         SHOW,
         TRACE,
         UNDEFINE_PATH,
         UNLABELED,
         UNTRACE,
         INFERENCE,
         ACTING,
         PARSING,
         EQUALITY,
         IMPLICATION,
         OR_ENTAILMENT,
         AND_ENTAILMENT,
         NOT,
         ANDOR,
         AND,
         OR,
         NAND,
         NOR,
         XOR,
         IFF,
         THRESH,
         ALL,
         COMMA,
         COLON,
         OPEN_PARAN,
         CLOSE_PARAN,
         OPEN_CURLY,
         CLOSE_CURLY,
         WITHSOME,
         WITHALL,
         WFF,
         IFDO,
         WHENDO,
         WHENEVERDO,
         ACTPLAN,
         EFFECT,
         GOALPLAN,
         PRECONDITION,
         KPLUS,
         KSTAR,
         COMPOSE,
         CONVERSE,
         IRREFLEXIVE_RESTRICT,
         DOMAIN_RESTRICT,
         RANGE_RESTRICT,
         CFRES,
         BANGPATH,
         EMPTYPATH;

terminal String FILEPATH,
                STRING_LIT,
                INT_LIT,
                IDENTIFIER,
                NUMERICAL_ENTAILMENT,
                EXPAND,
         	    REDUCE,
         	    NONE;

/* Non-terminals */

nonterminal String command,
                   wffNameCommand,
                   wffCommand,
                   snepslogCommand,
                   snepslogFunction,
                   terminalPunctuation,
                   optionalDot,
                   optionalTerminalPunctuation,
                   andOrEquality,
                   wffName,
                   optionalIdentifier;
                   
nonterminal ArrayList<String>  identifiers,
                               identifiers_list;
                   
nonterminal Path path,
                 snepsPath;
nonterminal LinkedList<Path> paths;
                               
nonterminal Node wff,
                 infixedTerm,
                 entailment,
                 prefixedTerm,
                 negatedTerm, 
                 andorTerm, 
                 setTerm, 
                 threshTerm, 
                 allTerm, 
                 atomicTerm,
                 withsomeTerm,
                 withallTerm,
                 ifdoTerm,
                 whendoTerm,
                 wheneverdoTerm,
                 actplanTerm,
                 effectTerm,
                 goalplanTerm,
                 preconditionTerm,
                 snepslogSymbol,
                 qvar;

nonterminal ArrayList<Node> pTermSet,
                            termSet,
                            termSequence,
                            prefixedTerms, 
                            symbolSequence,
                            snepslogSymbols,
                            optionalPTermSet;
                             
nonterminal ArrayList<ArrayList<Node>> termSetSequence,
                                       termSets;

/* Precedences */


/* The grammar */

command ::= 	wffNameCommand:wnc
		{: 
			RESULT = wnc;
		:}
		| snepslogCommand:sc
		{: 
			RESULT = sc;
		:}
		| wffCommand:wc
		{: 
			RESULT = wc;
		:};	

wffNameCommand ::= wffName:wn terminalPunctuation:tp
		   {: 
				Node w = Network.getNodes().get("M"+wn.substring(3));   
				ArrayList<Node> nodes = new ArrayList<>();
				ArrayList<Node> matchingNodes = new ArrayList<>();
				switch (tp) {
				case ".":
					try {
						Controller.addPropToCurrentContext(w.getId());
						nodes.add(w);
						RESULT = AP.displayWffs(nodes);
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					}
					break;
				case "!":
					nodes = AP.forwardInference(w, "!");
					RESULT = AP.displayWffs(nodes);
					break;
				case "??":
					matchingNodes = AP.match(w);
					for(int i=0;i<matchingNodes.size();i++){
						if(Controller.getCurrentContext().isAsserted((PropositionNode) matchingNodes.get(i))){
							nodes.add(matchingNodes.get(i));
						}
					}
					if (!nodes.isEmpty()) {
						RESULT = AP.displayWffs(nodes);
					} else {
						RESULT = "";
					}
					break;
				case "?":
					matchingNodes = AP.match(w);
					for(int i=0;i<matchingNodes.size();i++){
						ArrayList<Node> temp = AP.deduce(matchingNodes.get(i), "?", -1, -1);
						for(int j=0;j<temp.size();j++){
							nodes.add(temp.get(j));
						}
					}
					RESULT = AP.displayWffs(nodes);
					break;
				default:
					if (tp.startsWith("ONE")) {
						int i = Integer.parseInt(tp.substring(3));
						matchingNodes = AP.match(w);
					    for(int a=0;a<matchingNodes.size();a++){
							ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, -1);
							for(int b=0;b<temp.size();b++){
								nodes.add(temp.get(b));
							}
						}
						RESULT = AP.displayWffs(nodes);
					} else {
						int i = Integer.parseInt(tp.substring(3).split(",")[0]);
						int j = Integer.parseInt(tp.substring(3).split(",")[1]);
						matchingNodes = AP.match(w);
						for(int a=0;a<matchingNodes.size();a++){
							ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, j);
							for(int b=0;b<temp.size();b++){
								nodes.add(temp.get(b));
							}
						}
						RESULT = AP.displayWffs(nodes);
					}
					break;
				}
		   :};	
				
wffCommand ::= wff:w terminalPunctuation:tp
		   {: 
				ArrayList<Node> nodes = new ArrayList<>();
				ArrayList<Node> matchingNodes = new ArrayList<>();
				switch (tp) {
				case ".":
					try {
						Controller.addPropToCurrentContext(w.getId());
						nodes.add(w);
						RESULT = AP.displayWffs(nodes);
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					}
					break;
				case "!":
					nodes = AP.forwardInference(w, "!");
					RESULT = AP.displayWffs(nodes);
					break;
				case "??":
					matchingNodes = AP.match(w);
					for(int i=0;i<matchingNodes.size();i++){
						if(Controller.getCurrentContext().isAsserted((PropositionNode) matchingNodes.get(i))){
							nodes.add(matchingNodes.get(i));
						}
					}
					if (!nodes.isEmpty()) {
						RESULT = AP.displayWffs(nodes);
					} else {
						RESULT = "";
					}
					break;
				case "?":
					matchingNodes = AP.match(w);
					for(int i=0;i<matchingNodes.size();i++){
						ArrayList<Node> temp = AP.deduce(matchingNodes.get(i), "?", -1, -1);
						for(int j=0;j<temp.size();j++){
							nodes.add(temp.get(j));
						}
					}
					RESULT = AP.displayWffs(nodes);
					break;
				default:
					if (tp.startsWith("ONE")) {
						int i = Integer.parseInt(tp.substring(3));
						matchingNodes = AP.match(w);
					    for(int a=0;a<matchingNodes.size();a++){
							ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, -1);
							for(int b=0;b<temp.size();b++){
								nodes.add(temp.get(b));
							}
						}
						RESULT = AP.displayWffs(nodes);
					} else {
						int i = Integer.parseInt(tp.substring(3).split(",")[0]);
						int j = Integer.parseInt(tp.substring(3).split(",")[1]);
						matchingNodes = AP.match(w);
						for(int a=0;a<matchingNodes.size();a++){
							ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, j);
							for(int b=0;b<temp.size();b++){
								nodes.add(temp.get(b));
							}
						}
						RESULT = AP.displayWffs(nodes);
					}
					break;
				}
		   :};	
				
snepslogCommand ::= ACTIVATE wff:w optionalDot
				{: 
					ArrayList<Node> output = AP.forwardInference(w, "activate");
					RESULT = AP.displayWffs(output);
				:}
				| ACTIVATE BANG wff:w optionalTerminalPunctuation
				{: 
                		ArrayList<Node> output = AP.forwardInference(w, "activate!");
					RESULT = AP.displayWffs(output);
				:}
				| ADD_TO_CONTEXT IDENTIFIER:id termSet:ts optionalDot
				{: 
					try {
						Controller.addPropsToContext(id, AP.arrayListToPropositionSet(ts));
						RESULT = "";
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					}
				:}
				| ASK wff:w optionalTerminalPunctuation
				{: 
					ArrayList<Node> output = AP.deduce(w, "ask", -1, -1);
					RESULT = AP.displayWffs(output);
				:}
				| ASKIFNOT wff:w optionalTerminalPunctuation
				{: 
					ArrayList<Node> output = AP.deduce(w, "askifnot", -1, -1);
					RESULT = AP.displayWffs(output);
				:}
				| ASKWH wff:w optionalTerminalPunctuation
				{: 
					ArrayList<Node> output = AP.deduce(w, "askwh", -1, -1);
					RESULT = AP.displayWffs(output);
				:}
				| ASKWHNOT wff:w optionalTerminalPunctuation
				{: 
					ArrayList<Node> output = AP.deduce(w, "askwhnot", -1, -1);
					RESULT = AP.displayWffs(output);
				:}
				| BELIEFS_ABOUT pTermSet:pts optionalDot
				{: 
					RESULT = AP.displayWffs(AP.beliefsAbout(pts));
				:}
				| BR_MODE optionalDot
				{: 
					RESULT = AP.getBrMode();
				:}
				| BR_MODE AUTO optionalDot
				{: 
					AP.setBrMode("auto");
					RESULT = "";
				:}
				| BR_MODE MANUAL optionalDot
				{: 
					AP.setBrMode("manual");
					RESULT = "";
				:}
				| CLEAR_INFER optionalDot
				{: 
					AP.clearInfer();
					RESULT = "";
				:}
				| CLEARKB optionalDot
				{: 
					AP.clearKnowledgeBase();
					RESULT = "The knowledge base is cleared.";
				:}
				| COPYRIGHT optionalDot
				{: 
					RESULT = "copyright statement goes here.";
				:}
				| DEFINE_FRAME IDENTIFIER:id1 IDENTIFIER:id2 identifiers_list:idl optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						AP.createModeThreeCaseFrame(id1, id2, idl, null);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_FRAME IDENTIFIER:id1 IDENTIFIER:id2 identifiers_list:idl STRING_LIT:sl optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						AP.createModeThreeCaseFrame(id1, id2, idl, sl);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_PATH IDENTIFIER:id snepsPath:sp optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.definePath(Network.getRelation(id),sp);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_SEMANTIC IDENTIFIER
				{: 

				:}
				| DEFINE_SEMANTIC IDENTIFIER IDENTIFIER
				{: 

				:}
				| DEFINE_SEMANTIC IDENTIFIER IDENTIFIER identifiers_list
				{: 

				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 EXPAND:a INT_LIT:l
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 REDUCE:a INT_LIT:l
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 NONE:a INT_LIT:l
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DESCRIBE_CONTEXT optionalIdentifier:oid optionalDot
				{: 
					if(oid!=null){
						RESULT = Controller.getContextByName(oid).toString();
					}else{
						RESULT = Controller.getCurrentContext().toString();
					}
				:}
				| DESCRIBE_TERMS optionalPTermSet:opts optionalDot
				{: 
					if(opts!=null){
						RESULT = AP.describeTerms(opts);
					}else{
						RESULT = AP.describeTerms(AP.getAllClosedNodesFromTheNetwork());
					}
				:}
				| EXPERT optionalDot
				{: 
					if(!AP.getPrintingMode().equals("expert")) {
						AP.setPrintingMode("expert");
						RESULT = "expert mode is turned on.";
					}else{
						RESULT = "expert mode is already in use.";
					}
				:}
				| LIST_ASSERTED_WFFS optionalIdentifier:oid optionalDot
				{: 
					if(oid!=null){
						RESULT = AP.displayWffs(AP.propositionSetToArrayList(Controller.getContextByName(oid).allAsserted()));
					}else{
						RESULT = AP.displayWffs(AP.propositionSetToArrayList(Controller.getCurrentContext().allAsserted()));
					}
				:}
				| LIST_CONTEXTS optionalDot
				{: 
					Set<String> contexts = Controller.getAllNamesOfContexts();
					String output = "";
					for (String context : contexts) {
						output+=context+'\n';
					}
					RESULT = output;		
				:}
				| LIST_TERMS optionalPTermSet:opts optionalDot
				{: 
					if(opts!=null){
						RESULT = AP.displayWffs(AP.getClosed(opts));
					}else{
						RESULT = AP.displayWffs(AP.getAllClosedNodesFromTheNetwork());
					}
				:}
				| LOAD FILEPATH:fp optionalDot
				{: 
					RESULT = AP.loadFile(fp);
				:}
				| NORMAL optionalDot
				{: 
					if(!AP.getPrintingMode().equals("normal")) {
						AP.setPrintingMode("normal");
						RESULT = "normal mode is turned on.";
					}else{
						RESULT = "normal mode is already in use.";
					}
				:}
				| PERFORM atomicTerm:at optionalDot
				{: 
					AP.perform(at);
					RESULT = "";
				:}
				| REMOVE_FROM_CONTEXT IDENTIFIER:id pTermSet:pts
				{: 
					AP.removeFromContext(id, AP.arrayListToPropositionSet(pts));
					RESULT = "";
				:}
				| SET_CONTEXT IDENTIFIER:id optionalPTermSet:opts
				{: 
					if(opts!=null){
						Controller.createContext(id, AP.arrayListToPropositionSet(opts));
					}else{
						Controller.createContext(id);
					}
					RESULT = "";
				:}
				| SET_DEFAULT_CONTEXT IDENTIFIER:id
				{: 
					Controller.setCurrentContext(id);
					RESULT = "";
				:}
				| SET_MODE_1 optionalDot
				{: 
					if(AP.getSnepslogMode()!=1) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(1);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 1.";
					}else{
						RESULT = "Mode 1 is already in use.";
					}
				:}
				| SET_MODE_2 optionalDot
				{: 
					if(AP.getSnepslogMode()!=2) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(2);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 2.";
					}else{
						RESULT = "Mode 2 is already in use.";
					}
				:}
				| SET_MODE_3 optionalDot
				{: 
					if(AP.getSnepslogMode()!=3) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(3);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 3.";
					}else{
						RESULT = "Mode 3 is already in use.";
					}
				:}
				| SHOW optionalPTermSet optionalDot
				{: 

				:}
				| TRACE snepslogFunction:sf optionalDot
				{: 
					AP.activateTracing(sf);
					RESULT = "";
				:}
				| UNDEFINE_PATH IDENTIFIER:id optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.undefinePath(Network.getRelation(id));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| UNLABELED optionalDot
				{: 
					if(!AP.getPrintingMode().equals("unlabeled")) {
						AP.setPrintingMode("unlabeled");
						RESULT = "unlabeled mode is turned on.";
					}else{
						RESULT = "unlabeled mode is already in use.";
					}
				:}
				| UNTRACE snepslogFunction:sf optionalDot
				{: 
					AP.deactivateTracing(sf);
					RESULT = "";
				:};	

snepslogFunction ::=	 INFERENCE
		     	{:
					RESULT = "inference";
		     	:}
		      	| ACTING
		     	{:
					RESULT = "acting";
		     	:}
		     	| PARSING
		     	{:
					RESULT = "parsing";
		     	:};
				
wff ::= infixedTerm:it
    {:
    		RESULT = it;
    :}
    | entailment:e
    {:
    		RESULT = e;
    :};				

infixedTerm ::= prefixedTerm:arg1 andOrEquality:type infixedTerm:arg2
            {:
    				RESULT = AP.buildInfixedTerm(type, arg1, arg2);
            :}
            | prefixedTerm:pt
            {:
            		RESULT = pt;
            :};

andOrEquality ::= AND
                   {:
             			RESULT = "and";
                   :}
                   | OR
                   {:
             			RESULT = "or";
                   :}
                   | EQUALITY
                   {:
             			RESULT = "equality";
                   :};

entailment ::= termSet:antecedents IMPLICATION termSet:consequents
           {:
    				RESULT = AP.buildEntailment("Implication", antecedents, consequents, null);
           :}
           | termSet:antecedents OR_ENTAILMENT termSet:consequents
           {:
           		RESULT = AP.buildEntailment("OrEntailment", antecedents, consequents, null);
           :}
           | termSet:antecedents AND_ENTAILMENT termSet:consequents
           {:
           		RESULT = AP.buildEntailment("AndEntailment", antecedents, consequents, null);
           :}
           | termSet:antecedents NUMERICAL_ENTAILMENT:ne termSet:consequents
           {:
           		RESULT = AP.buildEntailment("NumericalEntailment", antecedents, consequents, ne.substring(0,ne.length()-2));
           :};
		
pTermSet ::= termSet:ts
         {:
    			ArrayList<Node> out = new ArrayList<Node>();
			for (int i = 0; i < ts.size(); i++) {
				ArrayList<Node> temp = AP.match(ts.get(i));
				for (int j = 0; j < temp.size(); j++) {
					out.add(temp.get(j));
				}
			}
			RESULT = out;
         :};		

termSet ::=	prefixedTerm:pt
		{:
			ArrayList<Node> temp = new ArrayList<Node>();
			temp.add(pt);
			RESULT = temp;
		:}
		| OPEN_CURLY termSequence:ts CLOSE_CURLY
		{:
			RESULT = ts;
		:};
		
termSequence ::= prefixedTerm:pt prefixedTerms:pts
             {:
             	ArrayList<Node> out = new ArrayList<Node>();
             	out.add(pt);
				for (int i = 0; i < pts.size(); i++) {
					out.add(pts.get(i));				
				}
				RESULT = out;
             :};
	     	
prefixedTerms ::= COMMA prefixedTerm:pt prefixedTerms:pts
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(pt);
					for (int i = 0; i < pts.size(); i++) {
						out.add(pts.get(i));				
					}
					RESULT = out;
			  :}
			  | 
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
					RESULT = out;
		      :};
		     
prefixedTerm ::= negatedTerm:t
			 {:
				RESULT = t;
			 :}
			 | andorTerm:t
			 {:
				RESULT = t;
		     :}
		     | setTerm:t
			 {:
				RESULT = t;
		     :}
		     | threshTerm:t
			 {:
				RESULT = t;
		     :}
		     | ifdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | whendoTerm:t
			 {:
				RESULT = t;
		     :}
		     | wheneverdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | actplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | effectTerm:t
			 {:
				RESULT = t;
		     :}
		     | goalplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | preconditionTerm:t
			 {:
				RESULT = t;
		     :}
		     | allTerm:t
			 {:
				RESULT = t;
		     :}
		     | atomicTerm:t
			 {:
				RESULT = t;
		     :};
		     
negatedTerm ::= NOT atomicTerm:node
		    {:
				RESULT = AP.buildNegatedTerm(node);
			:};
			
andorTerm ::= ANDOR OPEN_PARAN INT_LIT:i COMMA INT_LIT:j CLOSE_PARAN termSet:arguments
		  {:
				RESULT = AP.buildAndorTerm(i, j, arguments);
		  :};
	
setTerm ::= AND termSet:arguments
        {:
             RESULT = AP.buildSetTerm("and", arguments);
        :}
        | OR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("or", arguments);
        :}
        | NAND termSet:arguments
        {:
             RESULT = AP.buildSetTerm("nand", arguments);
        :}
        | NOR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("nor", arguments);
        :}
        | XOR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("xor", arguments);
        :}
        | IFF termSet:arguments
        {:
             RESULT = AP.buildSetTerm("iff", arguments);
        :};

threshTerm ::= THRESH OPEN_PARAN INT_LIT:thresh COMMA INT_LIT:threshmax CLOSE_PARAN termSet:arguments
           {:
             	RESULT = AP.buildThreshTerm(thresh, threshmax, arguments);
           :}
           | THRESH OPEN_PARAN INT_LIT:thresh CLOSE_PARAN termSet:arguments
           {:
             	RESULT = AP.buildThreshTerm(thresh, arguments.size()-1+"", arguments);
           :};

ifdoTerm ::= IFDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
         {:
				RESULT = AP.buildSNeRETerm("ifdo", arg1, arg2);
		 :};
		 
whendoTerm ::= WHENDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
           {:
				RESULT = AP.buildSNeRETerm("whendo", arg1, arg2);
		   :};
		   
wheneverdoTerm ::= WHENEVERDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
               {:
					RESULT = AP.buildSNeRETerm("wheneverdo", arg1, arg2);
		       :};
		   
actplanTerm ::= ACTPLAN OPEN_PARAN atomicTerm:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
            {:
				RESULT = AP.buildSNeRETerm("ActPlan", arg1, arg2);
		    :};
		       
effectTerm ::= EFFECT OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
           {:
				RESULT = AP.buildSNeRETerm("Effect", arg1, arg2);
	       :};
		       
goalplanTerm ::= GOALPLAN OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
             {:
				RESULT = AP.buildSNeRETerm("GoalPlan", arg1, arg2);
		     :};		     

preconditionTerm ::= PRECONDITION OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
                 {:
					RESULT = AP.buildSNeRETerm("Precondition", arg1, arg2);
		         :};

allTerm ::= ALL OPEN_PARAN symbolSequence CLOSE_PARAN OPEN_PARAN wff CLOSE_PARAN
		{:
			
		:};

atomicTerm ::= wffName
           {:
           
           :}
           | qvar
           {:
           
           :}
           | IDENTIFIER
           {:
           
           :}
           | IDENTIFIER COLON IDENTIFIER
           {:
           
           :}
           | withsomeTerm
           {:
           
           :}
           | withallTerm
           {:
           
           :}
           | qvar OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | IDENTIFIER OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | wffName OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | OPEN_PARAN wff CLOSE_PARAN
           {:
           
           :};

withsomeTerm ::= WITHSOME OPEN_PARAN symbolSequence:vars COMMA termSet:suchthat COMMA termSet:doo COMMA termSet:elsee CLOSE_PARAN
             {:
             	RESULT = AP.buildWithsomeAllTerm("withsome", vars, suchthat, doo, elsee);
             :}
             | WITHSOME OPEN_PARAN symbolSequence:vars COMMA termSet:suchthat COMMA termSet:doo CLOSE_PARAN
             {:
             	RESULT = AP.buildWithsomeAllTerm("withsome", vars, suchthat, doo, null);
             :};
             
withallTerm ::= WITHALL OPEN_PARAN symbolSequence:vars COMMA termSet:suchthat COMMA termSet:doo COMMA termSet:elsee CLOSE_PARAN
             {:
             	RESULT = AP.buildWithsomeAllTerm("withall", vars, suchthat, doo, elsee);
             :}
             | WITHALL OPEN_PARAN symbolSequence:vars COMMA termSet:suchthat COMMA termSet:doo CLOSE_PARAN
             {:
             	RESULT = AP.buildWithsomeAllTerm("withall", vars, suchthat, doo, null);
             :};
		         
termSetSequence ::= termSet:ts termSets:tss
                {:
					ArrayList<ArrayList<Node>> out = new ArrayList<ArrayList<Node>>();
             		out.add(ts);
					for (int i = 0; i < tss.size(); i++) {
						out.add(tss.get(i));				
					}
					RESULT = out;
		        :};

termSets ::= COMMA termSet:ts termSets:tss
	     {:
			tss.add(ts);
			RESULT = tss;
	     :}
	     | 
		 {:
			RESULT = new ArrayList<ArrayList<Node>>();
		 :};
		 
symbolSequence ::= snepslogSymbol:ss snepslogSymbols:sss
               {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(ss);
					for (int i = 0; i < sss.size(); i++) {
						out.add(sss.get(i));				
					}
					RESULT = out;
		       :};

snepslogSymbols ::= COMMA snepslogSymbol:ss snepslogSymbols:sss
	            {:
	            		sss.add(ss);
					RESULT = sss;
	            :}
	            | 
		        {:
					RESULT = new ArrayList<Node>();
		        :};

wffName ::= WFF INT_LIT:il
	    {:
			RESULT = "wff"+il;
	    :};
	    
qvar ::= QUESTION_MARK snepslogSymbol:ss
	 {:
		RESULT = ss;
	 :};

snepslogSymbol ::= IDENTIFIER
               {:
               		RESULT = Network.buildVariableNode();
               :};

terminalPunctuation ::= DOT
                    {:
           				RESULT = ".";
                    :}
                    | BANG
                    {:
                     	RESULT = "!";
                    :}
                    | QUESTION_MARK QUESTION_MARK
                    {:
           				RESULT = "??";
                    :}
                    | QUESTION_MARK
                    {:
           				RESULT = "?";
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il CLOSE_PARAN
                    {:
           				RESULT = "ONE"+il;
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il1 INT_LIT:il2 CLOSE_PARAN
                    {:
           				RESULT = "TWO"+il1+","+il2;
                    :};
							
optionalDot ::= DOT
			{:
				RESULT = ".";
			:}
			| 
			{:
				RESULT = null;
			:};	

optionalIdentifier ::= IDENTIFIER:id
			       {:
			       		RESULT = id;
			       :}
			       |
			       {:
			       		RESULT = null;
			       :};
			
optionalTerminalPunctuation ::= terminalPunctuation:tp
							{:
								RESULT = tp;
							:}
							| 
							{:
								RESULT = null;
							:};					
							
optionalPTermSet ::=	 pTermSet:pts
				 {:
					RESULT = pts;
				 :}
				 | 
				 {:
					RESULT = null;
				 :};		

identifiers ::= IDENTIFIER:id identifiers:ids
            {:
            		ids.add(id);
            		RESULT = ids;
            :}
            |
            {:
				RESULT = new ArrayList<String>();
            :};

identifiers_list ::= OPEN_PARAN IDENTIFIER:id identifiers:ids CLOSE_PARAN
                 {:
                 	ArrayList<String> out = new ArrayList<String>();
             		out.add(id);
					for (int i = 0; i < ids.size(); i++) {
						out.add(ids.get(i));				
					}
					RESULT = out;
                 :};			          	

path ::= snepsPath:sp
     {:
     	RESULT = sp;
     :}
     | BANGPATH
     {:
     	RESULT = new BangPath();
     :}
     | EMPTYPATH
     {:
     	RESULT = new EmptyPath();
     :};
						
snepsPath ::= IDENTIFIER:id
	      {:
				if(id.charAt(id.length()-1)=='-'){
					RESULT = new BUnitPath(Network.getRelation(id));
				}else{
					RESULT = new FUnitPath(Network.getRelation(id));
				}
          :}
	      | CFRES OPEN_PARAN IDENTIFIER:id1 COMMA IDENTIFIER:id2 CLOSE_PARAN
        	  {:
				if(id1.charAt(id1.length()-1)=='-'){
					RESULT = new CFResBUnitPath(Network.getRelation(id1), Network.getCaseFrame(id2));
				}else{
					RESULT = new CFResFUnitPath(Network.getRelation(id1), Network.getCaseFrame(id2));
				}
	      :}
     	  | KPLUS OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new KPlusPath(p);
	      :}
	      | KSTAR OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new KStarPath(p);
	      :}
	      | AND OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new AndPath(ps);
	      :}
	      | AND OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new AndPath(new LinkedList<Path>());
	      :}
	      | OR OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new OrPath(ps);
     	 :}
	      | OR OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new OrPath(new LinkedList<Path>());
	      :}
	      | COMPOSE OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new ComposePath(ps);
	      :}
	      | COMPOSE OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new ComposePath(new LinkedList<Path>());
	      :}
	      | CONVERSE OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new ConversePath(p);
	      :}
	      | IRREFLEXIVE_RESTRICT OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new IrreflexiveRestrictPath(p);
	      :}
	      | DOMAIN_RESTRICT OPEN_PARAN path:p1 OPEN_PARAN wff:w CLOSE_PARAN COMMA path:p2 CLOSE_PARAN
	      {:
				RESULT = new DomainRestrictPath(p1,w,p2);
	      :}
	      | RANGE_RESTRICT OPEN_PARAN path:p1 COMMA path:p2 OPEN_PARAN wff:w CLOSE_PARAN CLOSE_PARAN
	      {:
				RESULT = new RangeRestrictPath(p1,p2,w);
	      :};
	 
paths ::= path:p COMMA paths:ps
      {:
      		ps.add(p);
      		RESULT = ps;
      :}
      | path:p
      {:
      		LinkedList<Path> out = new LinkedList<Path>();
      		out.add(p);
      		RESULT = out;
      :};
				 																																																																																																																																																										