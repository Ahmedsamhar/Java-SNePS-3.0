package sneps.snepslog;

import java.io.*;
import java_cup.runtime.*;

import java.util.ArrayList;

import sneps.network.Node;
import sneps.network.Network;
import sneps.network.paths.Path;


parser code {:
String command;
:};
	
/* Terminals (tokens returned by the scanner). */

terminal ACTIVATE,
         BANG,
         DOT,
         ADD_TO_CONTEXT,
         ASK,
         ASKIFNOT,
         ASKWH,
         ASKWHNOT,
         BELIEFS_ABOUT,
         BR_MODE,
         AUTO,
         MANUAL,
         CLEAR_INFER,
         CLEARKB,
         COPYRIGHT,
         DEFINE_FRAME,
         DEFINE_PATH,
         DEFINE_SEMANTIC,
         DEFINE_RELATION,
         EXPAND,
         REDUCE,
         NONE,
         QUESTION_MARK,
         DESCRIBE_CONTEXT,
         DESCRIBE_TERMS,
         EXPERT,
         LIST_ASSERTED_WFFS,
         LIST_CONTEXTS,
         LIST_TERMS,
         LOAD,
         NORMAL,
         PERFORM,
         REMOVE_FROM_CONTEXT,
         SET_CONTEXT,
         SET_DEFAULT_CONTEXT,
         SET_MODE_1,
         SET_MODE_2,
         SET_MODE_3,
         SHOW,
         TRACE,
         UNDEFINE_PATH,
         UNLABELED,
         UNTRACE,
         INFERENCE,
         ACTING,
         PARSING,
         EQUALITY,
         IMPLICATION,
         OR_ENTAILMENT,
         AND_ENTAILMENT,
         NOT,
         ANDOR,
         AND,
         OR,
         NAND,
         NOR,
         XOR,
         IFF,
         THRESH,
         ALL,
         COMMA,
         COLON,
         OPEN_PARAN,
         CLOSE_PARAN,
         OPEN_CURLY,
         CLOSE_CURLY,
         WITHSOME,
         WITHALL,
         WFF,
         IFDO,
         WHENDO,
         WHENEVERDO,
         ACTPLAN,
         EFFECT,
         GOALPLAN,
         PRECONDITION,
         KPLUS,
         KSTAR,
         COMPOSE,
         CONVERSE,
         IRREFLEXIVE_RESTRICT,
         DOMAIN_RESTRICT,
         RANGE_RESTRICT,
         CFRES,
         BANGPATH,
         EMPTYPATH;

terminal String FILEPATH,
                STRING_LIT,
                INT_LIT,
                IDENTIFIER,
                NUMERICAL_ENTAILMENT;

/* Non-terminals */

nonterminal String command,
                   wffNameCommand,
                   wffCommand,
                   snepslogCommand,
                   snepslogFunction,
                   terminalPunctuation,
                   optionalDot,
                   optionalTerminalPunctuation,
                   andOrEquality,
                   wffName,
                   optionalIdentifier;
                   
nonterminal ArrayList<String>  identifiers,
                               identifiers_list;
                   
nonterminal Path path,
                 snepsPath;
nonterminal ArrayList<Path> paths;
                               
nonterminal Node wff,
                 infixedTerm,
                 entailment,
                 prefixedTerm,
                 negatedTerm, 
                 andorTerm, 
                 setTerm, 
                 threshTerm, 
                 allTerm, 
                 atomicTerm,
                 withsomeTerm,
                 withallTerm,
                 ifdoTerm,
                 whendoTerm,
                 wheneverdoTerm,
                 actplanTerm,
                 effectTerm,
                 goalplanTerm,
                 preconditionTerm,
                 snepslogSymbol,
                 qvar;

nonterminal ArrayList<Node> pTermSet,
                            termSet,
                            termSequence,
                            prefixedTerms, 
                            symbolSequence,
                            snepslogSymbols,
                            optionalPTermSet;
                             
nonterminal ArrayList<ArrayList<Node>> termSetSequence,
                                       termSets;

/* Precedences */

precedence left COMMA, BANG, DOT, QUESTION_MARK;

/* The grammar */

command ::= 	wffNameCommand
		{: 

		:}
		| snepslogCommand:sc
		{: 
			RESULT = sc;
		:}
		| wffCommand
		{: 

		:};	

wffNameCommand ::= wffName terminalPunctuation
				{: 
				
				:};
				
wffCommand ::= wff terminalPunctuation
		   {: 
				
		   :};	
				
snepslogCommand ::= ACTIVATE wff optionalDot
				{: 
					RESULT = "This functionality is still under development.";
				:}
				| ACTIVATE BANG wff optionalTerminalPunctuation
				{: 
                		RESULT = "This functionality is still under development.";
				:}
				| ADD_TO_CONTEXT IDENTIFIER termSet optionalDot
				{: 

				:}
				| ASK wff optionalTerminalPunctuation
				{: 

				:}
				| ASKIFNOT wff optionalTerminalPunctuation
				{: 

				:}
				| ASKWH wff optionalTerminalPunctuation
				{: 

				:}
				| ASKWHNOT wff optionalTerminalPunctuation
				{: 

				:}
				| BELIEFS_ABOUT pTermSet optionalDot
				{: 

				:}
				| BR_MODE optionalDot
				{: 

				:}
				| BR_MODE AUTO optionalDot
				{: 

				:}
				| BR_MODE MANUAL optionalDot
				{: 

				:}
				| CLEAR_INFER optionalDot
				{: 
					RESULT = "This functionality is still under development.";
				:}
				| CLEARKB optionalDot
				{: 
					AP.clearKnowledgeBase();
					RESULT = "The knowledge base is cleared.";
				:}
				| COPYRIGHT optionalDot
				{: 
					RESULT = "copyright statement goes here.";
				:}
				| DEFINE_FRAME IDENTIFIER IDENTIFIER identifiers_list optionalDot
				{: 

				:}
				| DEFINE_FRAME IDENTIFIER IDENTIFIER identifiers_list STRING_LIT optionalDot
				{: 

				:}
				| DEFINE_PATH IDENTIFIER snepsPath optionalDot
				{: 

				:}
				| DEFINE_SEMANTIC IDENTIFIER
				{: 

				:}
				| DEFINE_SEMANTIC IDENTIFIER IDENTIFIER
				{: 

				:}
				| DEFINE_SEMANTIC IDENTIFIER IDENTIFIER identifiers_list
				{: 

				:}
				| DEFINE_RELATION IDENTIFIER IDENTIFIER
				{: 

				:}
				| DEFINE_RELATION IDENTIFIER IDENTIFIER EXPAND INT_LIT
				{: 

				:}
				| DEFINE_RELATION IDENTIFIER IDENTIFIER REDUCE INT_LIT
				{: 

				:}
				| DEFINE_RELATION IDENTIFIER IDENTIFIER NONE INT_LIT
				{: 

				:}
				| DESCRIBE_CONTEXT optionalIdentifier optionalDot
				{: 

				:}
				| DESCRIBE_TERMS optionalPTermSet optionalDot
				{: 

				:}
				| EXPERT optionalDot
				{: 
					if(!AP.getPrintingMode().equals("expert")) {
						AP.setPrintingMode("expert");
						RESULT = "expert mode is turned on.";
					}else{
						RESULT = "expert mode is already in use.";
					}
				:}
				| LIST_ASSERTED_WFFS optionalIdentifier optionalDot
				{: 

				:}
				| LIST_CONTEXTS optionalDot
				{: 

				:}
				| LIST_TERMS optionalPTermSet optionalDot
				{: 

				:}
				| LOAD FILEPATH optionalDot
				{: 

				:}
				| NORMAL optionalDot
				{: 
					if(!AP.getPrintingMode().equals("normal")) {
						AP.setPrintingMode("normal");
						RESULT = "normal mode is turned on.";
					}else{
						RESULT = "normal mode is already in use.";
					}
				:}
				| PERFORM atomicTerm optionalDot
				{: 

				:}
				| REMOVE_FROM_CONTEXT IDENTIFIER pTermSet
				{: 

				:}
				| SET_CONTEXT IDENTIFIER optionalPTermSet
				{: 

				:}
				| SET_DEFAULT_CONTEXT IDENTIFIER
				{: 

				:}
				| SET_MODE_1 optionalDot
				{: 
					if(AP.getSnepslogMode()!=1) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(1);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 1.";
					}else{
						RESULT = "Mode 1 is already in use.";
					}
				:}
				| SET_MODE_2 optionalDot
				{: 
					if(AP.getSnepslogMode()!=2) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(2);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 2.";
					}else{
						RESULT = "Mode 2 is already in use.";
					}
				:}
				| SET_MODE_3 optionalDot
				{: 
					if(AP.getSnepslogMode()!=3) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(3);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 3.";
					}else{
						RESULT = "Mode 3 is already in use.";
					}
				:}
				| SHOW optionalPTermSet optionalDot
				{: 

				:}
				| TRACE snepslogFunction optionalDot
				{: 

				:}
				| UNDEFINE_PATH IDENTIFIER optionalDot
				{: 

				:}
				| UNLABELED optionalDot
				{: 
					if(!AP.getPrintingMode().equals("unlabeled")) {
						AP.setPrintingMode("unlabeled");
						RESULT = "unlabeled mode is turned on.";
					}else{
						RESULT = "unlabeled mode is already in use.";
					}
				:}
				| UNTRACE snepslogFunction optionalDot
				{: 

				:};	

snepslogFunction ::=	 INFERENCE
		     	{:
			
		     	:}
		      	| ACTING
		     	{:
			
		     	:}
		     	| PARSING
		     	{:
			
		     	:};
				
wff ::= infixedTerm:it
    {:
    		RESULT = it;
    :}
    | entailment:e
    {:
    		RESULT = e;
    :};				

infixedTerm ::= prefixedTerm:arg1 andOrEquality:type infixedTerm:arg2
            {:
    				RESULT = AP.buildInfixedTerm(type, arg1, arg2);
            :}
            | prefixedTerm:pt
            {:
            		RESULT = pt;
            :};

andOrEquality ::= AND
                   {:
             			RESULT = "and";
                   :}
                   | OR
                   {:
             			RESULT = "or";
                   :}
                   | EQUALITY
                   {:
             			RESULT = "equality";
                   :};

entailment ::= termSet:antecedents IMPLICATION termSet:consequents
           {:
    				RESULT = AP.buildEntailment("Implication", antecedents, consequents, null);
           :}
           | termSet:antecedents OR_ENTAILMENT termSet:consequents
           {:
           		RESULT = AP.buildEntailment("OrEntailment", antecedents, consequents, null);
           :}
           | termSet:antecedents AND_ENTAILMENT termSet:consequents
           {:
           		RESULT = AP.buildEntailment("AndEntailment", antecedents, consequents, null);
           :}
           | termSet:antecedents NUMERICAL_ENTAILMENT:ne termSet:consequents
           {:
           		RESULT = AP.buildEntailment("NumericalEntailment", antecedents, consequents, ne.substring(0,ne.length()-2));
           :};
		
pTermSet ::= termSet:ts
         {:
    			ArrayList<Node> out = new ArrayList<Node>();
			for (int i = 0; i < ts.size(); i++) {
				ArrayList<Node> temp = AP.match(ts.get(i));
				for (int j = 0; j < temp.size(); j++) {
					out.add(temp.get(j));
				}
			}
			RESULT = out;
         :};		

termSet ::=	prefixedTerm:pt
		{:
			ArrayList<Node> temp = new ArrayList<Node>();
			temp.add(pt);
			RESULT = temp;
		:}
		| OPEN_CURLY termSequence:ts CLOSE_CURLY
		{:
			RESULT = ts;
		:};
		
termSequence ::= prefixedTerm:pt prefixedTerms:pts
             {:
             	ArrayList<Node> out = new ArrayList<Node>();
             	out.add(pt);
				for (int i = 0; i < pts.size(); i++) {
					out.add(pts.get(i));				
				}
				RESULT = out;
             :};
	     	
prefixedTerms ::= COMMA prefixedTerm:pt prefixedTerms:pts
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(pt);
					for (int i = 0; i < pts.size(); i++) {
						out.add(pts.get(i));				
					}
					RESULT = out;
			  :}
			  | 
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
					RESULT = out;
		      :};
		     
prefixedTerm ::= negatedTerm:t
			 {:
				RESULT = t;
			 :}
			 | andorTerm:t
			 {:
				RESULT = t;
		     :}
		     | setTerm:t
			 {:
				RESULT = t;
		     :}
		     | threshTerm:t
			 {:
				RESULT = t;
		     :}
		     | ifdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | whendoTerm:t
			 {:
				RESULT = t;
		     :}
		     | wheneverdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | actplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | effectTerm:t
			 {:
				RESULT = t;
		     :}
		     | goalplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | preconditionTerm:t
			 {:
				RESULT = t;
		     :}
		     | allTerm:t
			 {:
				RESULT = t;
		     :}
		     | atomicTerm:t
			 {:
				RESULT = t;
		     :};
		     
negatedTerm ::= NOT atomicTerm:node
		    {:
				RESULT = AP.buildNegatedTerm(node);
			:};
			
andorTerm ::= ANDOR OPEN_PARAN INT_LIT:i COMMA INT_LIT:j CLOSE_PARAN termSet:arguments
		  {:
				RESULT = AP.buildAndorTerm(i, j, arguments);
		  :};
	
setTerm ::= AND termSet:arguments
        {:
             RESULT = AP.buildSetTerm("and", arguments);
        :}
        | OR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("or", arguments);
        :}
        | NAND termSet:arguments
        {:
             RESULT = AP.buildSetTerm("nand", arguments);
        :}
        | NOR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("nor", arguments);
        :}
        | XOR termSet:arguments
        {:
             RESULT = AP.buildSetTerm("xor", arguments);
        :}
        | IFF termSet:arguments
        {:
             RESULT = AP.buildSetTerm("iff", arguments);
        :};

threshTerm ::= THRESH OPEN_PARAN INT_LIT:thresh COMMA INT_LIT:threshmax CLOSE_PARAN termSet:arguments
           {:
             	RESULT = AP.buildThreshTerm(thresh, threshmax, arguments);
           :}
           | THRESH OPEN_PARAN INT_LIT:thresh CLOSE_PARAN termSet:arguments
           {:
             	RESULT = AP.buildThreshTerm(thresh, arguments.size()-1+"", arguments);
           :};

ifdoTerm ::= IFDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
         {:
				RESULT = AP.buildSNeRETerm("ifdo", arg1, arg2);
		 :};
		 
whendoTerm ::= WHENDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
           {:
				RESULT = AP.buildSNeRETerm("whendo", arg1, arg2);
		   :};
		   
wheneverdoTerm ::= WHENEVERDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
               {:
					RESULT = AP.buildSNeRETerm("wheneverdo", arg1, arg2);
		       :};
		   
actplanTerm ::= ACTPLAN OPEN_PARAN atomicTerm:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
            {:
				RESULT = AP.buildSNeRETerm("ActPlan", arg1, arg2);
		    :};
		       
effectTerm ::= EFFECT OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
           {:
				RESULT = AP.buildSNeRETerm("Effect", arg1, arg2);
	       :};
		       
goalplanTerm ::= GOALPLAN OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
             {:
				RESULT = AP.buildSNeRETerm("GoalPlan", arg1, arg2);
		     :};		     

preconditionTerm ::= PRECONDITION OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
                 {:
					RESULT = AP.buildSNeRETerm("Precondition", arg1, arg2);
		         :};

allTerm ::= ALL OPEN_PARAN symbolSequence CLOSE_PARAN OPEN_PARAN wff CLOSE_PARAN
		{:
			
		:};

atomicTerm ::= wffName
           {:
           
           :}
           | qvar
           {:
           
           :}
           | IDENTIFIER
           {:
           
           :}
           | IDENTIFIER COLON IDENTIFIER
           {:
           
           :}
           | withsomeTerm
           {:
           
           :}
           | withallTerm
           {:
           
           :}
           | qvar OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | IDENTIFIER OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | wffName OPEN_PARAN termSetSequence CLOSE_PARAN
           {:
           
           :}
           | OPEN_PARAN wff CLOSE_PARAN
           {:
           
           :};

withsomeTerm ::= WITHSOME OPEN_PARAN symbolSequence COMMA termSet COMMA termSet COMMA termSet CLOSE_PARAN
             {:
             
             :}
             | WITHSOME OPEN_PARAN symbolSequence COMMA termSet COMMA termSet CLOSE_PARAN
             {:
             
             :};
             
withallTerm ::= WITHALL OPEN_PARAN symbolSequence COMMA termSet COMMA termSet COMMA termSet CLOSE_PARAN
             {:
             
             :}
             | WITHALL OPEN_PARAN symbolSequence COMMA termSet COMMA termSet CLOSE_PARAN
             {:
             
             :};
		         
termSetSequence ::= termSet:ts termSets:tss
                {:
					ArrayList<ArrayList<Node>> out = new ArrayList<ArrayList<Node>>();
             		out.add(ts);
					for (int i = 0; i < tss.size(); i++) {
						out.add(tss.get(i));				
					}
					RESULT = out;
		        :};

termSets ::= COMMA termSet:ts termSets:tss
	     {:
			tss.add(ts);
			RESULT = tss;
	     :}
	     | 
		 {:
			RESULT = new ArrayList<ArrayList<Node>>();
		 :};
		 
symbolSequence ::= snepslogSymbol:ss snepslogSymbols:sss
               {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(ss);
					for (int i = 0; i < sss.size(); i++) {
						out.add(sss.get(i));				
					}
					RESULT = out;
		       :};

snepslogSymbols ::= COMMA snepslogSymbol:ss snepslogSymbols:sss
	            {:
	            		sss.add(ss);
					RESULT = sss;
	            :}
	            | 
		        {:
					RESULT = new ArrayList<Node>();
		        :};

wffName ::= WFF INT_LIT:il
	    {:
			RESULT = "wff"+il;
	    :};
	    
qvar ::= QUESTION_MARK snepslogSymbol:ss
	 {:
		RESULT = ss;
	 :};

snepslogSymbol ::= wffName:wn
               {:
               		RESULT = Network.buildVariableNode();
               :}
               | IDENTIFIER
               {:
               		RESULT = Network.buildVariableNode();
               :};

terminalPunctuation ::= DOT
                    {:
           				RESULT = ".";
                    :}
                    | BANG
                    {:
                     	RESULT = "!";
                    :}
                    | QUESTION_MARK QUESTION_MARK
                    {:
           				RESULT = "??";
                    :}
                    | QUESTION_MARK
                    {:
           				RESULT = "?";
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il CLOSE_PARAN
                    {:
           				RESULT = "ONE"+il;
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il1 INT_LIT:il2 CLOSE_PARAN
                    {:
           				RESULT = "TWO"+il1+","+il2;
                    :};
							
optionalDot ::= DOT
			{:
				RESULT = ".";
			:}
			| 
			{:
				RESULT = null;
			:};	

optionalIdentifier ::= IDENTIFIER:id
			       {:
			       		RESULT = id;
			       :}
			       |
			       {:
			       		RESULT = null;
			       :};
			
optionalTerminalPunctuation ::= terminalPunctuation:tp
							{:
								RESULT = tp;
							:}
							| 
							{:
								RESULT = null;
							:};					
							
optionalPTermSet ::=	 pTermSet:pts
				 {:
					RESULT = pts;
				 :}
				 | 
				 {:
					RESULT = null;
				 :};		

identifiers ::= IDENTIFIER:id identifiers:ids
            {:
            		ids.add(id);
            		RESULT = ids;
            :}
            |
            {:
				RESULT = new ArrayList<String>();
            :};

identifiers_list ::= OPEN_PARAN IDENTIFIER:id identifiers:ids CLOSE_PARAN
                 {:
                 	ArrayList<String> out = new ArrayList<String>();
             		out.add(id);
					for (int i = 0; i < ids.size(); i++) {
						out.add(ids.get(i));				
					}
					RESULT = out;
                 :};			          	

path ::= snepsPath
     {:
     
     :}
     | BANGPATH
     {:
     
     :}
     | EMPTYPATH
     {:
     
     :};
						
snepsPath ::= IDENTIFIER
	      {:
			
          :}
	      | CFRES OPEN_PARAN IDENTIFIER COMMA IDENTIFIER CLOSE_PARAN
        	  {:
			
	      :}
     	  | KPLUS OPEN_PARAN path CLOSE_PARAN
	      {:
			
	      :}
	      | KSTAR OPEN_PARAN path CLOSE_PARAN
	      {:
			
	      :}
	      | AND OPEN_PARAN paths CLOSE_PARAN
	      {:
			
	      :}
	      | AND OPEN_PARAN CLOSE_PARAN
	      {:
			
	      :}
	      | OR OPEN_PARAN paths CLOSE_PARAN
	      {:
			
     	 :}
	      | OR OPEN_PARAN CLOSE_PARAN
	      {:
			
	      :}
	      | COMPOSE OPEN_PARAN paths CLOSE_PARAN
	      {:
			
	      :}
	      | COMPOSE OPEN_PARAN CLOSE_PARAN
	      {:
			
	      :}
	      | CONVERSE OPEN_PARAN path CLOSE_PARAN
	      {:
			
	      :}
	      | IRREFLEXIVE_RESTRICT OPEN_PARAN path CLOSE_PARAN
	      {:
			
	      :}
	      | DOMAIN_RESTRICT OPEN_PARAN path OPEN_PARAN wff CLOSE_PARAN COMMA path CLOSE_PARAN
	      {:
			
	      :}
	      | RANGE_RESTRICT OPEN_PARAN path COMMA path OPEN_PARAN wff CLOSE_PARAN CLOSE_PARAN
	      {:
			
	      :};
	 
paths ::= path COMMA paths
      {:
      
      :}
      | path
      {:
      
      :};
				 																																																																																																																																																										